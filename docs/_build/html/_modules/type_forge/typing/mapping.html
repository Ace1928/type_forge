

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>type_forge.typing.mapping &mdash; Type Forge 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/autodoc_pydantic.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=38b66d78"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Type Forge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Type Forge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">type_forge.typing.mapping</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for type_forge.typing.mapping</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Type Mapping Utilities for the Type Forge System</span>
<span class="sd">===============================================</span>

<span class="sd">This module contains utilities for type categorization, relationship mapping,</span>
<span class="sd">and descriptive information about types. These functions enable semantic analysis</span>
<span class="sd">of type relationships beyond simple inheritance hierarchies.</span>

<span class="sd">Core functionalities include:</span>
<span class="sd">- Type categorization (atomic, container, protocol, etc.)</span>
<span class="sd">- Finding common supertypes across multiple types</span>
<span class="sd">- Converting between type names and Python type objects</span>
<span class="sd">- Generating human-readable type descriptions</span>
<span class="sd">- Analyzing type structure and relationships</span>

<span class="sd">These utilities serve as the foundation for more complex type operations</span>
<span class="sd">in the Type Forge system, enabling precise type handling with elegant</span>
<span class="sd">error management and comprehensive edge case coverage.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Final</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Protocol</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">get_args</span><span class="p">,</span>
    <span class="n">get_origin</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">type_forge.typing.definitions</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeCategory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">type_forge.typing.validation</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_subclass_safe</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">__version__</span>  <span class="c1"># noqa: F401</span>

<div class="viewcode-block" id="version">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.version">[docs]</a>
<span class="n">version</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">__version__</span></div>


<span class="c1"># Type variables for better type specificity</span>
<div class="viewcode-block" id="T">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.T">[docs]</a>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="U">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.U">[docs]</a>
<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span></div>


<span class="c1"># Type aliases for clarity and precision</span>
<div class="viewcode-block" id="TypeObject">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.TypeObject">[docs]</a>
<span class="n">TypeObject</span> <span class="o">=</span> <span class="n">Type</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span></div>

<div class="viewcode-block" id="TypeName">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.TypeName">[docs]</a>
<span class="n">TypeName</span> <span class="o">=</span> <span class="nb">str</span></div>

<div class="viewcode-block" id="TypeDescription">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.TypeDescription">[docs]</a>
<span class="n">TypeDescription</span> <span class="o">=</span> <span class="nb">str</span></div>

<div class="viewcode-block" id="MaybeType">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.MaybeType">[docs]</a>
<span class="n">MaybeType</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TypeObject</span><span class="p">]</span></div>


<span class="c1"># ──────────────────────────────────────────────────────────────</span>
<span class="c1"># Type Mapping Functions</span>
<span class="c1"># ──────────────────────────────────────────────────────────────</span>


<div class="viewcode-block" id="get_type_category">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.get_type_category">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_type_category</span><span class="p">(</span><span class="n">typ</span><span class="p">:</span> <span class="n">TypeObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeCategory</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the semantic category of a type.</span>

<span class="sd">    Categorizes types into meaningful groups based on their structure</span>
<span class="sd">    and behavior rather than just their inheritance relationships.</span>

<span class="sd">    Args:</span>
<span class="sd">        typ: The type to categorize</span>

<span class="sd">    Returns:</span>
<span class="sd">        TypeCategory: The semantic category of the type</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; get_type_category(int)</span>
<span class="sd">        &lt;TypeCategory.ATOMIC: &#39;atomic&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_type_category(list)</span>
<span class="sd">        &lt;TypeCategory.CONTAINER: &#39;container&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_type_category(dict)</span>
<span class="sd">        &lt;TypeCategory.CONTAINER: &#39;container&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_type_category(Protocol)  # doctest: +SKIP</span>
<span class="sd">        &lt;TypeCategory.PROTOCOL: &#39;protocol&#39;&gt;</span>

<span class="sd">    Note:</span>
<span class="sd">        This function uses both inheritance and structural properties</span>
<span class="sd">        to determine the category.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Atomic types - use tuple for faster membership testing</span>
    <span class="n">atomic_types</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TypeObject</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">int</span><span class="p">,</span>
        <span class="nb">float</span><span class="p">,</span>
        <span class="nb">bool</span><span class="p">,</span>
        <span class="nb">str</span><span class="p">,</span>
        <span class="nb">bytes</span><span class="p">,</span>
        <span class="nb">complex</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">atomic_types</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">ATOMIC</span>

    <span class="c1"># Container types - check safely without potential TypeErrors</span>
    <span class="n">container_types</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">TypeObject</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">container_type</span> <span class="ow">in</span> <span class="n">container_types</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_subclass_safe</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">container_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">CONTAINER</span>

    <span class="c1"># Function types - check safely</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">typ</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">FUNCTION</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># Continue processing if typ can&#39;t be checked for callability</span>
        <span class="k">pass</span>

    <span class="c1"># Protocol types - check for the specific protocol attribute</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s2">&quot;_is_protocol&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s2">&quot;_is_protocol&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">PROTOCOL</span>

    <span class="c1"># Generic types - check for presence of __origin__ attribute</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s2">&quot;__origin__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">GENERIC</span>

    <span class="c1"># Structural types (dataclasses, named tuples, etc.)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">STRUCTURAL</span>

    <span class="c1"># By default, consider it a composite type</span>
    <span class="k">return</span> <span class="n">TypeCategory</span><span class="o">.</span><span class="n">COMPOSITE</span></div>



<div class="viewcode-block" id="get_python_type_for_name">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.get_python_type_for_name">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_python_type_for_name</span><span class="p">(</span><span class="n">type_name</span><span class="p">:</span> <span class="n">TypeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaybeType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the Python type object corresponding to a type name.</span>

<span class="sd">    Maps common type names to their corresponding Python type objects,</span>
<span class="sd">    handling both builtin types and common collection types.</span>

<span class="sd">    Args:</span>
<span class="sd">        type_name: Name of the type as a string</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optional[Type[object]]: The corresponding Python type, or None if not found</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; get_python_type_for_name(&quot;int&quot;)</span>
<span class="sd">        &lt;class &#39;int&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_python_type_for_name(&quot;str&quot;)</span>
<span class="sd">        &lt;class &#39;str&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_python_type_for_name(&quot;list&quot;)</span>
<span class="sd">        &lt;class &#39;list&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_python_type_for_name(&quot;unknown&quot;) is None</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; get_python_type_for_name(&quot;STRING&quot;)  # Case insensitive</span>
<span class="sd">        &lt;class &#39;str&#39;&gt;</span>

<span class="sd">    Note:</span>
<span class="sd">        Currently handles only common builtin types. For more complex types,</span>
<span class="sd">        consider eval() with appropriate safety measures.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create an identity type constructor to preserve type safety</span>
    <span class="c1"># while allowing use of typing constructs in the mapping dictionary</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_type_identity</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">TypeObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeObject</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="c1"># Comprehensive mapping of type names to their Python types</span>
    <span class="c1"># Using a consistent type constructor for all entries</span>
    <span class="n">type_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TypeObject</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Primitive types</span>
        <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
        <span class="s2">&quot;integer&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
        <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;double&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
        <span class="s2">&quot;boolean&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
        <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span>
        <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span>
        <span class="s2">&quot;bytes&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">bytes</span><span class="p">),</span>
        <span class="s2">&quot;bytearray&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">),</span>
        <span class="s2">&quot;complex&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">complex</span><span class="p">),</span>
        <span class="s2">&quot;none&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
        <span class="s2">&quot;nonetype&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
        <span class="s2">&quot;null&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
        <span class="c1"># Collection types</span>
        <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span>
        <span class="s2">&quot;dict&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">dict</span><span class="p">),</span>
        <span class="s2">&quot;dictionary&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">dict</span><span class="p">),</span>
        <span class="s2">&quot;tuple&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">tuple</span><span class="p">),</span>
        <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">set</span><span class="p">),</span>
        <span class="s2">&quot;frozenset&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">),</span>
        <span class="c1"># Other common types</span>
        <span class="s2">&quot;object&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="nb">type</span><span class="p">),</span>
        <span class="s2">&quot;path&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="n">Path</span><span class="p">),</span>
        <span class="s2">&quot;callable&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">),</span>
        <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">),</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">make_type_identity</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1"># Handle typing module constructs separately to maintain type safety</span>
    <span class="c1"># Only add these when in a type checking context</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;typing&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">typing_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TypeObject</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;union&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Union</span><span class="p">),</span>
            <span class="s2">&quot;optional&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Optional</span><span class="p">),</span>
            <span class="s2">&quot;mapping&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">),</span>
            <span class="s2">&quot;collection&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Collection</span><span class="p">),</span>
            <span class="s2">&quot;protocol&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">),</span>
            <span class="s2">&quot;literal&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Literal</span><span class="p">),</span>
            <span class="s2">&quot;generic&quot;</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">,</span> <span class="n">Generic</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">type_map</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">typing_map</span><span class="p">)</span>

    <span class="c1"># Normalize input (lowercase) and look up in map</span>
    <span class="n">normalized_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">type_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">normalized_name</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_common_supertype">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.get_common_supertype">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_common_supertype</span><span class="p">(</span><span class="n">types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TypeObject</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">MaybeType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the most specific common supertype of multiple types.</span>

<span class="sd">    Identifies the closest common ancestor type that all the given</span>
<span class="sd">    types inherit from, providing the tightest type bound.</span>

<span class="sd">    Args:</span>
<span class="sd">        types: List of types to find a common supertype for</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optional[Type[object]]: The common supertype, or None if only object is common</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; get_common_supertype([int, float])  # doctest: +SKIP</span>
<span class="sd">        &lt;class &#39;numbers.Number&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_common_supertype([list, tuple])  # doctest: +SKIP</span>
<span class="sd">        &lt;class &#39;collections.abc.Sequence&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; get_common_supertype([str, int]) is object</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; get_common_supertype([]) is None</span>
<span class="sd">        True</span>

<span class="sd">    Note:</span>
<span class="sd">        Returns object if no more specific common supertype exists.</span>
<span class="sd">        Returns None for an empty list of types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Get all superclasses for each type</span>
    <span class="n">all_mros</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TypeObject</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># t is already known to be a type, so no need for isinstance check</span>
            <span class="n">all_mros</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="c1"># Fallback for objects without proper MRO</span>
            <span class="n">all_mros</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">object</span><span class="p">])</span>

    <span class="c1"># Find common elements in all MROs</span>
    <span class="n">common_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">TypeObject</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_mros</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">mro</span> <span class="ow">in</span> <span class="n">all_mros</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">common_types</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">mro</span><span class="p">)</span>

    <span class="c1"># If only object is common, return it directly</span>
    <span class="k">if</span> <span class="n">common_types</span> <span class="o">==</span> <span class="p">{</span><span class="nb">object</span><span class="p">}:</span>
        <span class="k">return</span> <span class="nb">object</span>

    <span class="c1"># Find the most specific (lowest in MRO) common type</span>
    <span class="n">best_type</span><span class="p">:</span> <span class="n">MaybeType</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">all_mros</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># Use first type&#39;s MRO as reference order</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">common_types</span><span class="p">:</span>
            <span class="n">best_type</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">best_type</span></div>



<div class="viewcode-block" id="get_type_name">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.get_type_name">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_type_name</span><span class="p">(</span><span class="n">typ</span><span class="p">:</span> <span class="n">TypeObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeName</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a user-friendly name for a type object.</span>

<span class="sd">    Creates a more readable name for types, handling special cases like</span>
<span class="sd">    NoneType and properly formatting generic types.</span>

<span class="sd">    Args:</span>
<span class="sd">        typ: The type to get a name for</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: A user-friendly name for the type</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; get_type_name(int)</span>
<span class="sd">        &#39;int&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_type_name(type(None))</span>
<span class="sd">        &#39;None&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_type_name(Dict[str, int])  # doctest: +SKIP</span>
<span class="sd">        &#39;Dict[str, int]&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_type_name(List[str])  # doctest: +SKIP</span>
<span class="sd">        &#39;List[str]&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_type_name(List)  # doctest: +SKIP</span>
<span class="sd">        &#39;List&#39;</span>

<span class="sd">    Note:</span>
<span class="sd">        This function creates names similar to those used in type annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle None type specially</span>
    <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;None&quot;</span>

    <span class="c1"># Handle Union types with more readable names</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get origin name</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">):</span>
            <span class="n">origin_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;typing.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Handle Union specially for better readability</span>
        <span class="k">if</span> <span class="n">origin_name</span> <span class="o">==</span> <span class="s2">&quot;Union&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

        <span class="c1"># Format generic type with arguments</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">origin_name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">args_str</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">return</span> <span class="n">origin_name</span>

    <span class="c1"># Basic case: just return the type name</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="c1"># Fallback</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;typing.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>  <span class="c1"># Remove typing. prefix</span></div>



<div class="viewcode-block" id="describe_type">
<a class="viewcode-back" href="../../../autoapi/type_forge/typing/mapping/index.html#type_forge.typing.describe_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">describe_type</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeDescription</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a detailed description of a value&#39;s type.</span>

<span class="sd">    Creates a human-readable description of an object&#39;s type,</span>
<span class="sd">    including additional information for collections.</span>

<span class="sd">    Args:</span>
<span class="sd">        value: The value to describe</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: A detailed description of the value&#39;s type</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; describe_type(42)</span>
<span class="sd">        &#39;int&#39;</span>
<span class="sd">        &gt;&gt;&gt; describe_type([1, 2, 3])</span>
<span class="sd">        &#39;list[int] (length: 3)&#39;</span>
<span class="sd">        &gt;&gt;&gt; describe_type({&#39;a&#39;: 1, &#39;b&#39;: &#39;text&#39;})</span>
<span class="sd">        &#39;dict[str, mixed] (size: 2)&#39;</span>
<span class="sd">        &gt;&gt;&gt; describe_type(None)</span>
<span class="sd">        &#39;None&#39;</span>

<span class="sd">    Note:</span>
<span class="sd">        For collections, includes element types and collection size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;None&quot;</span>

    <span class="c1"># Get basic type name</span>
    <span class="n">type_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="c1"># Add details for collections</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="p">:</span>
        <span class="c1"># Check if all elements are of the same type</span>
        <span class="n">list_value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">element_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">list_value</span><span class="p">}</span>
        <span class="n">element_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">element_types</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">element_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;mixed&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;list[</span><span class="si">{</span><span class="n">element_type</span><span class="si">}</span><span class="s2">] (length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">list_value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="p">:</span>
        <span class="c1"># For tuples, show individual element types</span>
        <span class="n">tuple_value</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">element_types_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">tuple_value</span><span class="p">]</span>
        <span class="n">unique_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">element_types_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">element_types_list</span><span class="p">:</span>
            <span class="c1"># Homogeneous tuple</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;tuple[</span><span class="si">{</span><span class="n">element_types_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">] (length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tuple_value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="n">element_types_list</span><span class="p">:</span>
            <span class="c1"># Heterogeneous tuple</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;tuple[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">element_types_list</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="p">:</span>
        <span class="c1"># For dictionaries, show key and value types</span>
        <span class="n">dict_value</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">key_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_value</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">value_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dict_value</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>

        <span class="n">key_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">key_types</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;mixed&quot;</span>
        <span class="n">value_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">value_types</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;mixed&quot;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;dict[</span><span class="si">{</span><span class="n">key_type</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">] (size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dict_value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">))</span> <span class="ow">and</span> <span class="n">value</span><span class="p">:</span>
        <span class="c1"># For sets, show element type</span>
        <span class="n">set_value</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">element_types</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">set_value</span><span class="p">}</span>
        <span class="n">element_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">element_types</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">element_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;mixed&quot;</span>
        <span class="p">)</span>
        <span class="n">set_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;set&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;frozenset&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">set_type</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">element_type</span><span class="si">}</span><span class="s2">] (size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">set_value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;str (length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="c1"># Default case: just the type name</span>
    <span class="k">return</span> <span class="n">type_name</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Lloyd Handyside.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>